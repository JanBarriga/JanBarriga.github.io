<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programaci√≥ amb Arduino</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script src="https://JanBarriga.github.io/robotica/arduino/programacio/arduino.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; position: relative; }
        code { font-family: monospace; }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i √©s la configuraci√≥.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 √©s una sortida de corrent o OUTPUT on puc connectar
      //un led.
}

void loop() { //√âs un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una instrucci√≥ de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> √©s una sortida digital i permet encendre i apagar
      //Nom√©s t√© 2 valors, HIGH i LOW (Enc√®s i apagat)
 delay(500);//√âs el temps en milisegons que ha d'estar, en aquest cas enc√®s.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Blink amb dos variables globals
//Avantatge principal: Quan canvio un n√∫mero al principi canviar√† tot el codi. 
//Segon avantatge: Tamb√© s'enten millor perqu√® jo poso els noms de les variables
//Desavantatge: √âs una mica m√©s llarg. 
int ledPin = 13;
int delayPeriod = 500; //Declarem 2 variables globals com a n√∫meros enters

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW); //Utilitzo una variable global
 delay(delayPeriod); //Utilitzo una altra variable global
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional

int ledPin = 13;
int delayPeriod = 100;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
 if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a comen√ßar, aix√≤ significa que quan arriba a 1000 torna a comen√ßar 
    //perqu√® hem posat que el delayPeriod sigui 100 de nou. 
    //Cada vegada √©s m√©s lent perqu√® el temps que triga en encendre i apagar-se √©s major.
    //Si vulgues que cada vegada sigui m√©s r√†pid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
    //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
    //if (delayPeriod == 100); delayPeriod = 1000;
    //Si vull que el canvi sigui m√©s lent s'hauria de posar un n√∫mero m√©s alt en "delayPeriod = delayPeriod + X"
    //Si vull que el canvi sigui m√©s r√†pid s'hauria de posar un n√∫mero m√©s petit en "delayPeriod = delayPeriod + X"
  delayPeriod = 100;
 }
}
</code></pre>
<p> En el seg√ºent codi podem veure com definim unes variables globals i les apliquem moltes vegades repetides dins del mateix 
    codi. Es un codi molt repetitiu </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// 02_07_blink_20 (Encendre i apagar manualment o Hard coded)
// variables globals, que s'utilitzaran moltes vegades repetides.
//avantatges: Es pot canviar el periode i el nombre de pin al principi (Variable global) i afecta a moltes linees
//de codi diferent. 

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}

</code></pre>
<p> Amb el seg√ºent codi, aconseguim el mateix resultat que m√©s amunt, es a dir, 
encendre i apagar 20 vegades amb un delay de 250 milisegons, per√≥ no ho escribim 20 
vegades, si no que fem un cicle for.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    // 02_08_blik_20_for

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
      //que s√≥n des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
      //Si volgu√©s podria canviar les condicions. fent que els numeros augmentesin diferent
      //(Per exemple i = i + 5)
      
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
  }
 delay(3000);
}
</code></pre>
<p> En el codi anterior, hem dit que repeteixi 20 vegades per√≤ es repeteix infinites vegades perqu√© es repeteix
20 vegades en un void loop. En el seg√ºent codi, posarem un contador i quan arribi a 20 repeticions s'aturar√†</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// 02_09_blink_20_loop (Aqui es nota perqu√©

int ledPin = 13;
int delayPeriod = 100;
int count = 0;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 count ++; //"Count" es una variable global que podria ser local, perqu√® nom√©s afecta al loop.
    //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funci√≥ que jo defineixi o
    //al setup
 if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a comen√ßar
   count = 0;
   delay(3000);
 }
}
 // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparaci√≥ estricta es a dir una comparaci√≥
// estricta, que compara tamb√© el tipus de variable. Si posem un igual "=" √©s una assignaci√≥ que pot ser temporal o constant
// si es posa "const" davant es 
</code></pre>
<p> El seg√ºent codi es el primer exemple de creaci√≥ d'una funci√≥. Una funci√≥ es com un programa dins dins d'un programa.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    // 03_01_blink_function

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}
// Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. √âs el que s'aplica continuadament. En aquest cas el "void loop()"
// el loop repeteix 20 vegades el flash.
// Com cridem una funci√≥?
// Nom√©s cal posar el nom de la funci√≥ dintre del loop per cridar-la i que s'executi sempre.
void loop() {
  for (int i = 0; i < 20; i ++) {
    flash();
  }
 delay(3000);
}
// per crear una funci√≥ nom√©s cal escriure el nom de la funci√≥ i uns parentesis. Si hagu√©s alguna cosa entre parentesi
//serian els parametres o arguments de la funci√≥. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
//triem un nom explicatiu del que fa la funci√≥, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
//nom dintre del void loop (per exemple). 
void flash() { 
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
}
</code></pre>
<p>A continuaci√≥ veurem el codi flash per√≤ amb par√†metres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funci√≥ te dos par√†metres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, √©s una variable local definida dins de la funci√≥ "flash"
        // i no te un valor predeterminat, nom√©s ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i &lt; numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }

        </code></pre>
    </div>
    
        <div class="content-container">
            <h1>Funcions en Arduino</h1>
            <p>Les funcions d'arduino s√≥n semblants a les funcions que veiem a cinem√†tica directa i inversa. En el cas de la cinem√†tica rob√≤tica 
                utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funci√≥ com per exemple, calculatePosition () era una funci√≥ 
                sense arguments o par√†metres que estava identificada amb un bloc de codianomenat function i s'executava quan clicavem un bot√≥. 
                Dintre d'aquest bloc hi havien instruccions que permeten fer c√†lculs matem√†tics. En el seg√ºent codi d'arduino, tenim una funcion 
                flash amb dos per√†metres que eren n√∫meros enters anomenat ledPin i de delayPeriod que identifiquen el pin que est√† connectat i el 
                temps que ha d'estar enc√®s o apagat.
            </p>
            <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle infinit loop. Ho aconseguim 
                amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi  i mai m√©s. La paraula static es deriva 
                del llenguatge C i Arduino √©s un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
        </div>

        <div class="content-container">
            <h1>Arrays i Strings</h1>
            <p>Una Array √©s una forma de contenir un llistat de valors, moltes vegades s√≥n valors enters i s'accedeix amb ells per la 
                seva posici√≥, sent la primera posici√≥ [0] del array o element 0. El codi seg√ºent el que fa √©s a la primera linia defineix una 
                array amb 9 valors, i els imprimeix en el monitor s√®rie els seus valors. Ser√† √∫til pel nostre codi morse.
            </p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
        </div>
        
        <div class="content-container">
            <p>El codi seg√ºent ja √©s un codi morse, perqu√® combina una array, un bucle for que llegeix l'array i l'aplica a la funci√≥ flash, 
                d'aquesta forma √©s com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200).
            </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
        </div>

        <div class="content-container">
            <p>Puc crear una funci√≥ que em serveix per quatre lletres i nom√®s quan la crido he de posar el n√∫mero de repeticions com 
                par√†metres o arguments</p>
        </div>

        <div class="content-container">
            <h1>Normes internacionals de codi Morse</h1>
            <ul>
                <li>Una l√≠nia (dash) √©s igual a tres punts</li>
                <li>L'espai entre les parts d'una meteixa lletra √©s igual a un punt (dot). (S = ¬∑¬∑¬∑, l'espai entre cada punt √©s un punt)</li>
                <li>L'espai entre dues lletres de la mateixa paraula s√≥n tres punts (Per exemple entre las S i la O de SOS)</li>
                <li>L'espai entre dues parules √©s igual a set punts (Pa ¬∑¬∑¬∑¬∑¬∑¬∑¬∑ tom√†quet)</li> 
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Aix√≤ √©s la lletra e
                    eosz(3); // Aix√≤ √©s la lletra s
                    eosz(2); // Aix√≤ √©s la lletra o
                }
            </code></pre>

            <p>Crearem una funci√≥ que ser√† v√†lida pels punts repetits i per les linies repetides amb dos par√†ametres.</p>

            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Aix√≤ √©s la t
                    eosztmo(3, 600); //Aix√≤ √©s la o
                    eosztmo(3, 200); //Aix√≤ √©s la s
                    eosztmo(1, 200); //Aix√≤ √©s la e
                }
            </code></pre>
            <p> L'objectiu del codi seg√ºent es entendre que les cadenes o strings s√≥n conjunts de caracters ASCII. I podem accedir amb ells amb arrays
            que estan formats per parentesis quadratss i el primer element es el 0. En llenguatge C i derivats del C com Arduino podem utilitzar punters o pointers
            que permeten apuntar a un element. En python o Javascript no hi ha pointers
            </p>
            <p> A continuaci√≥ es poden veure els caracters ASCII en una taula, que son els utilitzats en els strings.</p>
            <p> La taula seg√ºent esta basada en un codi binari de 7 bits, perqu√© 2^7 es 128, hi hauran desde 0 a 127 caracters diferents</p>
            <div>
                <table>
                    <thead>
                        <tr>
                            <th> ASCII </th>
                            <th> DECIMAL</th>
                            <th> BINARI </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>A-Z</td>
                            <td>65-90</td>
                            <td>0b100001-0b1011010</td>
                        </tr>
                        <tr>
                            <td>a-z</td>
                            <td>97-122</td>
                            <td>0b1100001-0b11110001</td>
                        </tr>
                        <tr>
                            <td> 0-9 </td>
                            <td> 48-57 </td>
                            <td> 0b110000-0b111001</td>github.com/JanBarriga/JanBarriga.github.io/edit/main/robotic
                        </tr>
                        <tr>
                            <td> Espai</td>
                            <td> 32 </td>
                            <td> 0b0100000</td>
                        </tr>
                    </tbody>
                </table>
            </div>
 <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
  d'intercambiar informaci√≥ amb ordinadors</p>
  <p>UTF8 √©s un sistema Unicode Transformation Format que permet escriure m√©s d'un mili√≥ de car√†cters diferents
  ‚ÄúüôÇ‚Äù U+1F642</p>
  <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    
// sketch 05-03

char message[] = "Hello"; //Hi ha un array simolitzat per "[]" que cont√© caracters "char". Cada car√†cter d'ASCII t√© assignat un valor de 7 bits. 
//Un valor de 7 bits va des de 0 fins a 127 perqu√® 2^7 √©s 128.

void setup() {
  Serial.begin(9600);
  message[0] = 'h';
}

void loop() {
  Serial.println(message);
  delay(1000);
}
</code></pre>
<h3>Import√†ncia dels punters + Exemple de codi Morse</h3>
            <p>Hi ha llenguatges amb i sense punters.</p> 
            <ul>
                <li>Exemples de llenguatges amb punters: C i els seus derivats com arduino</li>
                <li>Exemples de llenguatges sense punters: Python i Javascript</li>
            </ul>
            <p>El punter llegeix el contingut d'una adre√ßa de memoria i tambe la posici√≥ de la mateixa adre√ßa i pot manipular-la. Hi ha posicions d'adre√ßes especials, com els sectors d'arrancada.</p>
            <p>El punter serveix per tenir el control total per part del programador de la memoria i els recursos de l'ordinador</p>
            <p>El "Problema" que te es que pot provocar errors a la memoria o accesos no permesos si no saps com fer funcionar correctament el punter</p>
            <p>Els dos s√≠mbols per utilitzar punters son: L'arterisc "*", que serveix per llegir el contingut de l'adre√ßa de memoria. I l'ampersand "&", que llegieix la posici√≥ de l'adre√ßa de memoria</p>
            <p>La memoria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa te un valor unic assignat en hexadecimal que comen√ßa per 0x. Cada caixa te un contingut que pot ser buit (0) o pot contenir un valor</p>
    <h4>Operacions avan√ßades amb punters</h4>
            <ul>
                <li><b>Acc√©s directe a la memoria:</b> Permet modificar valors en posicions especifiques.</li>
                <li><b>Manipulaci√≥ eficient d'arrays i strings (cadenes):</b> L'array esencialment es una llista adre√ßes amb principi i final amb un punter al primer element.</li>
                <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva adre√ßa, estalviant memoria i temps. Aquest es un dels motius per els que C i derivats son mes rapids que python o JS.</li>
                <li><b>Creaci√≥ d'estructures dinamiques:</b> Es pot crear coses com grafics o llistes enlla√ßades de forma facil</li>
                <li><b>Interacci√≥ amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatges de baix nivell (low-level languages) que son mes properes al hardware. Encara que, gracies a l'augment de la memoria, s'han pogut crear llenguatges com micropython o circutpython.</li>
            </ul>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// Al principi del codi, abans de la funci√≥ de configuraci√≥ "setup" i la funci√≥ principal 
// "loop" que s'executa continuament, hem d'escriure sempre variables o constants.
// A m√©s, al principi del codi trobem les constants i variables globals, anomenades aix√≠ perqu√® es poden cridar
// o executar des de qualsevol part del codi, a diferencia de les variables locals que es 
// defineixen i s'utilitzen dintre de la mateixa funci√≥ "loop" o una funci√≥ addicional.
// Davant de les variables i constants globals hauriem d'afegir les biblioteques necess√†ries per 
// fer funcionar el nostre codi ( amb "#include <nom_biblioteca.h> ) l'extensi√≥ "h" deriva de C
// i significa "biblioteca de headers" o encap√ßalaments.        
const int ledPin = 13;
const int dotDelay = 200
// "const" vol dir que la variable no es modificar√† dins del codi, "int" vol dir integer, o sigui
// que el nombre que agafem haur√† de ser enter, ja que els pins tenen n√∫meros enters. El pin 13
// √©s especial, t√© una resist√®ncia interna en el cas d'Arduino uno que permet connectar directament
// un led, perqu√® est√† al costat del pin GND i puc clavar o connectar un led sense cap circuit o placa.
// "ledPin" √©s una variable constant i s'anomena aix√≠ per l'usuari, utilitzant camelCase i referint-nos
// al que fa aquest pin.
char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};
// M√©s amunt i m√©s abaix tinc dos arrays composats cadascun d'ells per arrays interns i cada array intern
// est√† composat de caracters que nom√©s poden ser "." o "-".
// Quan jo crido "letter[0]" el que obtinc ".-" o sigui, la lletra A en codi Morse.
// Aquesta forma de treballar √©s molt dolenta, des d'un punt de vista d'efici√®ncia perqu√® estic utilitzant.
// un byte ( un byte s√≥n 8 bits ) sencer per cada punt o ratlla. 
// Un bit √©s un valor de 0 o 1 i aix√≤ es podria utilitzar per fer els punts o ratlles perqu√® els dos valors
// s√≥n dos estats, o 0 o 1, es podria asignar el 0 al punt i la ratlla l'1, fent-ho m√©s eficient.
// En un byte hi han 8 bits i per aix√≤ es podrien fer 256 caracters diferents.
// Quants bytes de mem√≤ria necesitarem utilitzant bytes o bits per codificar Morse?
// Aproximadament el Morse t√© uns 109 punts o ratlles pels n√∫meros o lletres, de la manera m√©s eficient
// tindriem un √∫s de 14 bytes i de la manera menys eficient 872 bytes.
// Hem de tenir en compte
// De fet ASCII utilitza 7 bits per crear 128 caracters ( de 0 a 127 ).
// "*" √©s molt important, ja que ens indica que √©s un punter, "[]" ens indica que √©s una array,
//  "numbers" m'indica el valor de l'array, i char m'indica el tipus d'element ( que s√≥n caracters ) que hi ha dins
// de l'array.
// L'array de sota es diu numbers per√≤ est√† constituit per caracters, perqu√® tant els n√∫meros com les lletres
// estan constituides per "." o "-" que s√≥n caracters
char* numbers[] = {
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
//En el setup o configuraci√≥ del microcontrolador indiquem que el pin 13  que ara es diu "ledPin" sigui una sortida o "OUTPUT".
//Indiquem a l'Arduino que es comuniqui amb l'ordinador a trav√©s del port serial o s√®rie i connecti a una velocitat de 9600 bauds o simbols/segon que s√≥n aprox 9600 bits/sego.
}

    void loop() {
//El loop √©s el codi principal, i el que el seu nom indica √©s que es repeteix sense parar en un "loop".
//"char" significa que utilitzem una variable de tipus car√†cter i 'anomenem "ch".
//Serial.available significa si est√† disponible la comunicaci√≥ s√®rie o "serial monitor" que comunica el microcontrolador arduino amb el nostre ordinador o dispositiu
//La comunicaci√≥ entre arduino i l'ordinador √©s complexa:
//Primer pas: l'ordinador envia dades al monitor s√®rie a trav√©s de l'USB per un mecanisme que s'anomena "USB to serial"
//Segon pas: la transformaci√≥ anterior d'USB to Serial la fa un xip especial dintre d'Arduino
//Tercer pas: les dades en format s√®rie arriben a una part del microcontrolador amonenada "UART" que significa "Universal Asynchronous Receiver Transmiter" 
//Quart pas: l'UART envia les dades que rep a una mem√≤ria temporal o buffer que pot emmagatzemar 128 bytes fins que s'elimina en el moment que es llegeix.
    char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}

void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}

void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
</code></pre>
<p> Negaci√≥. El signe d'admiraci√≥ "!" significa negar la variable que es posa despr√©s del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definici√≥ del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta enc√©s per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input nom√©s 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el bot√≥, 
l'apaguem perqu√© la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge seg√ºent per veure la simulaci√≥ </p>
<a href = "https://www.tinkercad.com/things/6kmvYJBnQFx-circuit-54-monk" target = "_blank"> <img src = "54.PNG"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<a href = "https://www.tinkercad.com/things/ijQ7CKiIRbu-circuit-55-monk" target = "_blank"> <img src = "55.PNG"> </a>

<p>soluci√≥ amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
         #include <Bounce2.h>
        const int inputPin = 5;
        const int ledPin = 13;
        int ledValue = LOW;
        Bounce bouncer = Bounce(); 

        void setup() {
        pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin);
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) {
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        // El rebot de contacte (Contact Bounce) esta present en reles (Interruptors que canvia de estat depenent de l'electricitat), interruptors, contactes de bateria. Tots aquests
        // Estan fets per metalls elastics, de forma que quan yo apreto un interruptor mecanic, el metall rebota diverses vegades sobre el contacte, provocant una inestabilitat al
        // contacte
        }
        }
 </code>
</pre>
<p> Algunes sortides d'arduino i altres microcontroladors s√≥n PWM (Pulse Width Modulation). Com podem veure a la imatge de sota, es tracta
de una modulaci√≥ de l'ample del pols. Es a dir, es modula el temps que es 0 o que es 1, aconseguint que en 0 s'apagui i en 1 s'encengui.
Nosaltres no observem que s'encengui o que s'apagui perque es molt rapid el canvi i la nostra visi√≥ no ens permet veure-ho. Nosaltres veiem
la llum en un percentatge que depen del percentatge de temps que ha estat ences la sortida </p>
<img src = "pwm.png">

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter Volts 0 to 5");
}

void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0;
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Despr√©s de definir
el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
del programa Arduino IDE: Enter volts 0-5.</p>
<p> Al loop principal comprova que hi hagi car√†cters escrits a la consola, despr√©s agafa el valor que hem 
donat i el guarda en la variable volts. El valor pot ser en decimals perqu√® posa float ("Floating point number").
El m√®tode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en maj√∫scula, normalment
seria una classe en maj√∫scula) i agafa el valor de la consola s√®rie</p>
<p> La variable pwmValue √©s entera (int o "integer") i el que fa √©s convertir el valor de volts (0-5) a valors
de 0-255, que √©s el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
"Serial.println("Enter Volts 0-3.3")
"int pwmValue = volts * 16384.0 / 3.3" </p>

<p> El ESP32-S3 te l'avantatge de tenir m√©s resoluci√≥, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
Aix√≥ pot que no es noti en un led, per√≥ es nota en un motor, on l'ESP32 permet accedir a m√©s velocitats diferents. Els
motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no
</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600); //comen√ßa la comunicaci√≥ serie USB entre l'arduino i l'ordinador a una velocitat de 9600 bauds (Simbols per segon) l'objecte serial es de la clase serial
  //i si li apliquem la sintaxi del punt el metode begin que t√© com a parametre o argument. I li apliquem a la sintaxi de punt a la clase serie, pot rebre diversos parametres, si 
  //els posem entre cometes escriu tal qual, i si no posem entre cometes son variables 
  Serial.println("Enter Volts 0 to 5"); //demana que el usuari entri per el monitor del arduino ide un numero entre 0 i 5. 
}
//void loop es el codi principal que no s'atura mai, es a dir, es repeteix fins que desconectem l'arduino. El metode avaliable es un metode que espera caracters, < 0 es
//que hi ha algun caracter, Serial.parsefloat es una funci√≥ que te la funcio de analitzar el contingut d'un caracter, i si es de tipus decimal (floating point number),les variables
//float incloeixen els int o integer (numeros sencers). Tamb√© existeix el parse.int que nom√©s acceptaria numeros enters. El float volts crea un espai a la memoria anomenat volts,
//que haura de ser de floating point numbers, que emmagatzemara el valor parsejat del 
void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0; //els volts no serveixen directament, perque volem valors entre 0 i 255, ja que son els valors del PWM, perque es el numero de bits. faig una regla de tres i multiplico el valor per 255 i ho divideixo entre 5. 
    //aquest valor es integer, i va al m√©s proxim si dona decimal
    analogWrite(outputPin, pwmValue); 
  }
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600); // comen√ßa la comunicaci√≥ s√®rie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 s√≠mbols per segon).
}

void loop() {
  int number = random(1, 7); // escull un n√∫mero enter aleatoriament del 1 el 7. (1, 7) √©s un interval aix√≠ que agafem el 1, 2, 3...7
    // Els n√∫meros aleatoris s√≥n importants per exemple en controls de qualitat perque  ens asegurem de tot no est√† decidit 
    per ning√∫
  Serial.println(number); // Perqu√® fem println i no fem print? perqu√® volem que surti una l√≠nea sobre una altre
  delay(500); // espera 500 millisegons
}
    
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int analogPin = 0; // El pin 0 en Arduino √©s el pin A0 (analog)

void setup() {
  Serial.begin(9600);
}

void loop() {
  int reading = analogRead(analogPin); // analogRead llegeix els valors analogics del analogPin de 0 a 1023
  float voltage = reading / 204.6; // 1023 / 5 = 204,6 Dividim 1023 (2^10 - 1 per a Arduino) entre 5 (volts d'Arduino)
                        // Ara ens interesa els volts perqu√® jo connecto un sensor por esemple de temperatura ( de 0 a 100
    graus, d'humitat 0% - 100%) i els valor de 0 a 1023 no tenen sentit, perqu√® si fos un altre ESP32 seria de 0 a 4095
    i el valor 500 en el primer cas estaria per la meitat i en el segon cas seria menys. Si utilitzem voltatge tenim una mesura
    real del que est√† passat en el sensor i buscarem la relaci√≥ entre els volts i la temperatura / humitat a la fulla de 
    caracter√≠stiques (datasheet), una vegada tenir la relaci√≥ farem una regla de 3 o un mapejat.
  Serial.print("Reading="); // Quan poso entre cometes el print em surt tal qual la paraula reading= que significa lectura
  Serial.print(reading); // reading no t√© cometes i √©s una variable que cont√© valors entre 0 i 1023
  Serial.print("\t\tVolts="); // \t deixa un espai de tabulador. 
  Serial.println(voltage); // Ens donar√† el valor en volts al costat de Volts=
    // Com quedar√† en el cas de reading 512?
    // Reading=512        Volts=2.5 // espera mig segon per der una altre lectura
    // Reading=256        Volts=1.25
  delay(500);
}

</code></pre>


<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600); // comen√ßa la comunicaci√≥ s√®rie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 s√≠mbols per segon).
}

void loop() {
  int number = random(1, 7); // escull un n√∫mero enter aleatoriament del 1 el 7. (1, 7) √©s un interval aix√≠ que agafem el 1, 2, 3...7
    // Els n√∫meros aleatoris s√≥n importants per exemple en controls de qualitat perque  ens asegurem de tot no est√† decidit 
    per ning√∫
  Serial.println(number); // Perqu√® fem println i no fem print? perqu√® volem que surti una l√≠nea sobre una altre
  delay(500); // espera 500 millisegons
}
    
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0)); // seed significa llavor i t√© com argument un n√∫mero, si per exemple poso randomSeed (4) 
    sempre em sortir√† la mateixa cadena de n√∫meros aleatoris.
}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
</code></pre>
</div>

<div class="content-container">
    <h2>Numeros aleatoris, perque son imporannts y com es fan</h2>     
    <p> La funci√≥ random de Ardunio IDE deriva de la funci√≥ rnd del llenguatge C i C++ i fuaniona de la mateixa manera. 
        No genera n√∫meros aleatoris sin√≥ pseudoaleatois, perque estan creats per un algorisme o algoritme, anomenat "Generador l√≠neal congruecial". 
        Aquet algoritme √©s determinista, sempre onara els mateixos resulatats.
        La funci√≥ random necesita una llavo o seed per generar els n√∫meros i sin√≥ s'indica acostuma a ser 1 o 0, en Arduino √©s 1.  Donarem un exempe matematic</p>

                    
<h1>Generaci√≥ de Nombres Pseudoaleatoris: LCG + Arduino</h1>

<h2>1. Algorisme LCG (Linear Congruential Generator)</h2>
  <p>
    L‚Äôalgorisme congruencial lineal genera seq√º√®ncies pseudoaleat√≤ries segons la f√≥rmula de recursi√≥:
  </p>
  <div>
    \[
      X_{n+1} \;=\; \bigl(a \cdot X_n + c\bigr)\;\bmod\; m
    \]
  </div>
  <p>On:</p>
  <ul>
    <li><strong>\(X_n\)</strong> = valor anterior.</li>
    <li><strong>\(a\)</strong> = multiplicador.</li>
    <li><strong>\(c\)</strong> = increment.</li>
    <li><strong>\(m\)</strong> = m√≤dul.</li>
    <li><strong>\(X_0\)</strong> = llavor inicial (seed).</li>
  </ul>

  <h3>Exemple Num√®ric Pas a Pas</h3>
  <p>Suposem:</p>
  <ul>
    <li>\(a = 5\)</li>
    <li>\(c = 3\)</li>
    <li>\(m = 16\)</li>
    <li>\(X_0 = 7\)</li>
  </ul>
  <ol>
    <li>
      \(X_1 = (5 \times 7 + 3) \bmod 16 = 38 \bmod 16 = 6\)
    </li>
    <li>
      \(X_2 = (5 \times 6 + 3) \bmod 16 = 33 \bmod 16 = 1\)
    </li>
    <li>
      \(X_3 = (5 \times 1 + 3) \bmod 16 = 8  \bmod 16 = 8\)
    </li>
    <li>
      \(X_4 = (5 \times 8 + 3) \bmod 16 = 43 \bmod 16 = 11\)
    </li>
    <li>
      \(X_5 = (5 \times 11 + 3) \bmod 16 = 58 \bmod 16 = 10\)
    </li>
  </ol>
  <p><strong>Seq√º√®ncia completa:</strong> 7, 6, 1, 8, 11, 10</p>
<p>
  When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are
  \[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]
</p>
<h1> Numeros aleatoris i arduino </h1>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0));
}

void loop() {
  int number = random(1, 7);
  Serial.println(numbera);
  delay(500); 
}
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        void setup() {
    Serial.begin(9600);
    randomSeed(analogRead(0)); //genera numeros aleatoris de forma potent. Si dintre de randomSeed posem un n√∫mero, sempre
    //sortira el mateix n√∫mero aleatori com pasa amb el <a href="https://pompeu.neocities.org/arduino/random/seed">
    //exemple del profesor</a> on podem canviar la seed o llavor i comprovar-ho
    /*Aquests valors seran aleatoris en el cas que no hi hagi res conectat a A0. Si conectem un simple cable a A0 observarem que 
    quan toquem amb els dits o incl√∫s sense tocar hi ha un senyal de soroll que es mou entre 0 i 1023 mormalment pel rang baix. 
    L' aire √©s una barreja complexa de gasos en moviment i l'entrada anal√≤gica √©s un sistema molt sensible molt sensible en 
    aquests gasos. Resumint analogRead(0) donar√† alors eners aleatoris i ser√† la nostra primera capa d'aletorietar. La segona
    capa de la aletorietat √©s randomSeed perqu√® utilitza un algortme "lineal conggruencial", que es basa an un m√®tode recursiu,
    √©s a dir, que agafa el n√∫mero el multipliquem per un nuero fix que no cavia mai i el sumem amb el n√∫mero fiix que no canvia
    mai (nom√©s canvia si canviem el llenguatge de programaci√≥ o la versi√≥ del lleguate). Quan ja tenim aquest n√∫mero fem una
    operaci√≥ m√≤dul per obtenir el n√∫mero aleatori, aixo vol dir diiir el n√∫mero obtingut entre en n√∫mero conegut (sempre igual)
    i el residu ser√† pseudoaleatori. 
          
    Perque √©s pseudoaleatori?
    Sempre ser√† la mateixa se√ºencia si fessim randomSeed(4), i la mateixa seq√ºencia si fessim randomSeed(x) sent "x" qualsevol 
    n√∫mero.
    
    Perque no puc saber quin numero aleatori¬†sortir√†?
    Encara que hi ha una relaci√≥ matem√†tica entre el n√∫mero de llavor i el n√∫mero aleatori perqu√® el n√∫mero de llavor √©s aleatori
    (analogRead(0)). Perqu√® √©s un n√∫mero pseudoaleatori d'un n√∫mero aleatori perqu√® la funci√≥ randomSeed() √©s pseudoaleat√≤ria i 
    analogRead(0) √©s aleat√≤ria pel soroll de fons.

    Pot servir per tener sempre els mateios n√∫meros?
    S√≠, perqu√® quan triem una Seed determinada sempre tindrem una seq√º√®ncia. Pot ser √∫til perqu√® jo puc fer un aparell o 
    o programa amb una randomSeed(184) i si li dic a un altre investigador o altre fabricant de hardware la meva llavor (seed) 
    podr√† reproduir els meus resultats.

    A m√©s a m√©s de random hem de con√®ixer les funcions matem√†tiques d'Arduino que poden ser √∫tils per fer c√†lculs, per exemple, 
    per convertir valors de 0 a 1023 en valors de temperatura, humitat, concentraci√≥ d'un contaminant, etc.
    */

    
    <li>La <b>abs</b> donar√† el valor absolut ser√† el n√∫mero sense signe, per exemple abs(12) = 12, i abs(-12) = 12</li>
    <li>La funci√≥ <b>constrain</b> fa constrenyir o reduir un n√∫mero d'un rang determinat. La funci√≥ t√© 3 n√∫meros o arguments. 
    El primer argument √©s el n√∫mero que volem constrenyir, el segon n√∫mero √©s el principi del rang i el tercer n√∫mero √©s el final 
    del rang perm√®s.
    <ul>
      <li>constrain(8,1,10); ens retorna el n√∫mero 8, perques esta en el rang de 1 a 10.</li>
      <li>constrain(11,1,10); ens retorna el n√∫mero 10, ja que no pot ser m√©s gran que 10</li>
      <li>constrain(0,1,10); ens retorna el n√∫mero 1, ja que no pot ser m√©s petit que 1</li>
    </ul>
    </li>
    <li>La funci√≥ <b>map</b> t√© 5 arguments. El primer √©s el n√∫mero que ens interessa que est√† a dins del primer rang, el segon √©s 
        el n√∫mero m√≠nim del primer rang, el tercer n√∫mero √©s el m√†xim del primer rang, el quart √©s el n√∫mero m√≠nim del segon rang i 
        finalment, el cinqu√® n√∫mero √©s el n√∫mero m√†xim del tercer rang. Per exemple
        map(200, 0, 1023, 0, 100);
    </li>


}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
</code></pre>

</div>
</body>
</html>
