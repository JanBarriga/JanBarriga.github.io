<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programació amb Arduino</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/js/all.min.js"></script>
    <script src="https://JanBarriga.github.io/robotica/arduino/programacio/arduino.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        pre { background: #f4f4f4; padding: 10px; overflow-x: auto; position: relative; }
        code { font-family: monospace; }
        .copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
    </style>
    <script>
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.innerText;
            navigator.clipboard.writeText(codeBlock).then(() => {
                button.innerHTML = '<i class="fas fa-check"></i>';
                setTimeout(() => { button.innerHTML = '<i class="fas fa-copy"></i>'; }, 2000);
            });
        }
    </script>
</head>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//El meu primer codi: Blink
void setup() { //Codi que s'executa una vegada i és la configuració.
  pinMode(13, OUTPUT); //Estem dient que el pin 13 és una sortida de corrent o OUTPUT on puc connectar
      //un led.
}

void loop() { //És un codi que s'executa sense parar fins que desconnecto l'Arduino o li dono una instrucció de parada.
 digitalWrite(13, HIGH); // <b>digitalWrite</b> és una sortida digital i permet encendre i apagar
      //Només té 2 valors, HIGH i LOW (Encès i apagat)
 delay(500);//És el temps en milisegons que ha d'estar, en aquest cas encès.
 digitalWrite(13, LOW);//Aqui <b>digitalWrite</b> fa que s'apagui
 delay(500);
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Blink amb dos variables globals
//Avantatge principal: Quan canvio un número al principi canviarà tot el codi. 
//Segon avantatge: També s'enten millor perquè jo poso els noms de les variables
//Desavantatge: És una mica més llarg. 
int ledPin = 13;
int delayPeriod = 500; //Declarem 2 variables globals com a números enters

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW); //Utilitzo una variable global
 delay(delayPeriod); //Utilitzo una altra variable global
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
//Codi Blink amb un condicional

int ledPin = 13;
int delayPeriod = 100;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 delayPeriod = delayPeriod + 100; //Augmenta el temps 100 milisegons cada vegada
 if (delayPeriod == 1000) { //Quan arriba a 1000 milisegons torna a començar, això significa que quan arriba a 1000 torna a començar 
    //perquè hem posat que el delayPeriod sigui 100 de nou. 
    //Cada vegada és més lent perquè el temps que triga en encendre i apagar-se és major.
    //Si vulgues que cada vegada sigui més ràpid, i s'hauria de canviar varies coses: al principi del codi canviar la variable de 
    //int delayPeriod = 1000, a final de codi posar el menys a "delayPeriod = delayPeriod - 100", i finalment canviar el condicional per:
    //if (delayPeriod == 100); delayPeriod = 1000;
    //Si vull que el canvi sigui més lent s'hauria de posar un número més alt en "delayPeriod = delayPeriod + X"
    //Si vull que el canvi sigui més ràpid s'hauria de posar un número més petit en "delayPeriod = delayPeriod + X"
  delayPeriod = 100;
 }
}
</code></pre>
<p> En el següent codi podem veure com definim unes variables globals i les apliquem moltes vegades repetides dins del mateix 
    codi. Es un codi molt repetitiu </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// 02_07_blink_20 (Encendre i apagar manualment o Hard coded)
// variables globals, que s'utilitzaran moltes vegades repetides.
//avantatges: Es pot canviar el periode i el nombre de pin al principi (Variable global) i afecta a moltes linees
//de codi diferent. 

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);

 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 
 
 delay(3000);
}

</code></pre>
<p> Amb el següent codi, aconseguim el mateix resultat que més amunt, es a dir, 
encendre i apagar 20 vegades amb un delay de 250 milisegons, peró no ho escribim 20 
vegades, si no que fem un cicle for.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    // 02_08_blik_20_for

int ledPin = 13;
int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  for (int i = 0; i < 20; i ++) { //Dintre del cicle for, tenim les condicions que ha de complir el cicle
      //que són des de i = 0 fins a i = 20, ves augmentant un en un. O sigui i++ que es el mateix que i = i + 1
      //Si volgués podria canviar les condicions. fent que els numeros augmentesin diferent
      //(Per exemple i = i + 5)
      
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
  }
 delay(3000);
}
</code></pre>
<p> En el codi anterior, hem dit que repeteixi 20 vegades però es repeteix infinites vegades perqué es repeteix
20 vegades en un void loop. En el següent codi, posarem un contador i quan arribi a 20 repeticions s'aturarà</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// 02_09_blink_20_loop (Aqui es nota perqué

int ledPin = 13;
int delayPeriod = 100;
int count = 0;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
 digitalWrite(ledPin, HIGH);
 delay(delayPeriod);
 digitalWrite(ledPin, LOW);
 delay(delayPeriod);
 count ++; //"Count" es una variable global que podria ser local, perquè només afecta al loop.
    //si escric "int count; count ++;" estaria definint una variable local dintre del loop, i no es pot usar en una altre funció que jo defineixi o
    //al setup
 if (count == 20) { //Quan el comtador arriba a 20 deixa de fer parpadeigs de 100 milisegons i fa una aturada de 3 segons abans de tornar a començar
   count = 0;
   delay(3000);
 }
}
 // Dos iguals vol dir que es exactament igual. Si posem 3 iguals "===" es una comparació estricta es a dir una comparació
// estricta, que compara també el tipus de variable. Si posem un igual "=" és una assignació que pot ser temporal o constant
// si es posa "const" davant es 
</code></pre>
<p> El següent codi es el primer exemple de creació d'una funció. Una funció es com un programa dins dins d'un programa.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    // 03_01_blink_function

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}
// Aquest codi es el principal, anomenat com a "main" en alguns llenguatges. És el que s'aplica continuadament. En aquest cas el "void loop()"
// el loop repeteix 20 vegades el flash.
// Com cridem una funció?
// Només cal posar el nom de la funció dintre del loop per cridar-la i que s'executi sempre.
void loop() {
  for (int i = 0; i < 20; i ++) {
    flash();
  }
 delay(3000);
}
// per crear una funció només cal escriure el nom de la funció i uns parentesis. Si hagués alguna cosa entre parentesi
//serian els parametres o arguments de la funció. La paraula "void" en aquest cas es equivalent a la paraula "function" de javascript.
//triem un nom explicatiu del que fa la funció, i dintre de les claus posem les linees de codi que s'han d'executar quan la cridem pel seu
//nom dintre del void loop (per exemple). 
void flash() { 
   digitalWrite(ledPin, HIGH);
   delay(delayPeriod);
   digitalWrite(ledPin, LOW);
   delay(delayPeriod);
}
</code></pre>
<p>A continuació veurem el codi flash però amb paràmetres. </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_functrion_params
        
        const int ledPin = 13;
        const int delayPeriod = 250;
        
        void setup() {
          pinMode(ledPin, OUTPUT);
        }
        
        void loop() {
          flash(20, delayPeriod);
          delay(3000);
        }
        // Podem veure que la funció te dos paràmetres que son 2 nombres enters i que s'anomenen "numFlashes" i "d"
        // numFlashes no esta definit com a variable global, és una variable local definida dins de la funció "flash"
        // i no te un valor predeterminat, només ha de complir que sigui un valor enter. El mateix per a la variable "d"
        void flash(int numFlashes, int d) {
            for (int i = 0; i &lt; numFlashes; i++) {
            digitalWrite(ledPin, HIGH);
            delay(d);
            digitalWrite(ledPin, LOW);
            delay(d);
            }
            }

        </code></pre>
    </div>
    
        <div class="content-container">
            <h1>Funcions en Arduino</h1>
            <p>Les funcions d'arduino són semblants a les funcions que veiem a cinemàtica directa i inversa. En el cas de la cinemàtica robòtica 
                utilitzavem funcions Javascript dintre d'un codi HTML. Avans cada funció com per exemple, calculatePosition () era una funció 
                sense arguments o paràmetres que estava identificada amb un bloc de codianomenat function i s'executava quan clicavem un botó. 
                Dintre d'aquest bloc hi havien instruccions que permeten fer càlculs matemàtics. En el següent codi d'arduino, tenim una funcion 
                flash amb dos peràmetres que eren números enters anomenat ledPin i de delayPeriod que identifiquen el pin que està connectat i el 
                temps que ha d'estar encès o apagat.
            </p>
            <p> Ara farem que un bucle for ss'executi 20 o x vegades dintre d'unbucle for localitzat dintre d'un bucle infinit loop. Ho aconseguim 
                amb la paraula clau static, que fa que una variable s'inicialitzi una vegada que correm el codi  i mai més. La paraula static es deriva 
                del llenguatge C i Arduino és un derviat de C++ i Processing, </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
            // 03_03_blink_20_faulty

const int ledPin = 13;
const int delayPeriod = 250;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int count = 0;
  digitalWrite(ledPin, HIGH);
  delay(delayPeriod);
  digitalWrite(ledPin, LOW);
  delay(delayPeriod);
  count ++;
  if (count == 20) {
    count = 0;
    delay(3000);
  }
}
            </code></pre>
        </div>

        <div class="content-container">
            <h1>Arrays i Strings</h1>
            <p>Una Array és una forma de contenir un llistat de valors, moltes vegades són valors enters i s'accedeix amb ells per la 
                seva posició, sent la primera posició [0] del array o element 0. El codi següent el que fa és a la primera linia defineix una 
                array amb 9 valors, i els imprimeix en el monitor sèrie els seus valors. Serà útil pel nostre codi morse.
            </p>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                
int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  Serial.begin(9600);  
  for (int i = 0; i < 9; i++) {
    Serial.println(durations[i]);
  }
}

void loop() {

}
            </code></pre>
        </div>
        
        <div class="content-container">
            <p>El codi següent ja és un codi morse, perquè combina una array, un bucle for que llegeix l'array i l'aplica a la funció flash, 
                d'aquesta forma és com si escrivis flash(200), flash(200), flash(200), flash(500), flash(500), flash(500), flash(200), flash(200), flash(200).
            </p>
        <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int ledPin = 13;

int durations[] = {200, 200, 200, 500, 500, 500, 200, 200, 200};

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop()  {
  for (int i = 0; i < 9; i++) {
    flash(durations[i]);
  }
  delay(1000);
}

void flash(int duration) {
   digitalWrite(ledPin, HIGH);
   delay(duration);
   digitalWrite(ledPin, LOW);
   delay(duration);
}
        </code></pre>
        </div>

        <div class="content-container">
            <p>Puc crear una funció que em serveix per quatre lletres i nomès quan la crido he de posar el número de repeticions com 
                paràmetres o arguments</p>
        </div>

        <div class="content-container">
            <h1>Normes internacionals de codi Morse</h1>
            <ul>
                <li>Una línia (dash) és igual a tres punts</li>
                <li>L'espai entre les parts d'una meteixa lletra és igual a un punt (dot). (S = ···, l'espai entre cada punt és un punt)</li>
                <li>L'espai entre dues lletres de la mateixa paraula són tres punts (Per exemple entre las S i la O de SOS)</li>
                <li>L'espai entre dues parules és igual a set punts (Pa ······· tomàquet)</li> 
            </ul>
            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
                void eosz (int numFlashes) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(200);
                        digitalWrite(ledPin, LOW);
                        delay(200);
                    }
                }

                void loop(){
                    eosz(1); // Això és la lletra e
                    eosz(3); // Això és la lletra s
                    eosz(2); // Això és la lletra o
                }
            </code></pre>

            <p>Crearem una funció que serà vàlida pels punts repetits i per les linies repetides amb dos paràametres.</p>

            <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">


                void eosztmo (int numFlashes, int d) {
                    for (int i = 0; i < numFlashes; i++) {
                        digitalWrite(ledPin, HIGH);
                        delay(d);
                        digitalWrite(ledPin, LOW);
                        delay(d);
                    }
                }

                void loop(){
                    eosztmo(1, 600); //Això és la t
                    eosztmo(3, 600); //Això és la o
                    eosztmo(3, 200); //Això és la s
                    eosztmo(1, 200); //Això és la e
                }
            </code></pre>
            <p> L'objectiu del codi següent es entendre que les cadenes o strings són conjunts de caracters ASCII. I podem accedir amb ells amb arrays
            que estan formats per parentesis quadratss i el primer element es el 0. En llenguatge C i derivats del C com Arduino podem utilitzar punters o pointers
            que permeten apuntar a un element. En python o Javascript no hi ha pointers
            </p>
            <p> A continuació es poden veure els caracters ASCII en una taula, que son els utilitzats en els strings.</p>
            <p> La taula següent esta basada en un codi binari de 7 bits, perqué 2^7 es 128, hi hauran desde 0 a 127 caracters diferents</p>
            <div>
                <table>
                    <thead>
                        <tr>
                            <th> ASCII </th>
                            <th> DECIMAL</th>
                            <th> BINARI </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>A-Z</td>
                            <td>65-90</td>
                            <td>0b100001-0b1011010</td>
                        </tr>
                        <tr>
                            <td>a-z</td>
                            <td>97-122</td>
                            <td>0b1100001-0b11110001</td>
                        </tr>
                        <tr>
                            <td> 0-9 </td>
                            <td> 48-57 </td>
                            <td> 0b110000-0b111001</td>github.com/JanBarriga/JanBarriga.github.io/edit/main/robotic
                        </tr>
                        <tr>
                            <td> Espai</td>
                            <td> 32 </td>
                            <td> 0b0100000</td>
                        </tr>
                    </tbody>
                </table>
            </div>
 <p>ASCII significa American Standard Code for Information Interchange i va ser descrit a l'any 1967 amb l'objectiu 
  d'intercambiar informació amb ordinadors</p>
  <p>UTF8 és un sistema Unicode Transformation Format que permet escriure més d'un milió de caràcters diferents
  “🙂” U+1F642</p>
  <pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    
// sketch 05-03

char message[] = "Hello"; //Hi ha un array simolitzat per "[]" que conté caracters "char". Cada caràcter d'ASCII té assignat un valor de 7 bits. 
//Un valor de 7 bits va des de 0 fins a 127 perquè 2^7 és 128.

void setup() {
  Serial.begin(9600);
  message[0] = 'h';
}

void loop() {
  Serial.println(message);
  delay(1000);
}
</code></pre>
<h3>Importància dels punters + Exemple de codi Morse</h3>
            <p>Hi ha llenguatges amb i sense punters.</p> 
            <ul>
                <li>Exemples de llenguatges amb punters: C i els seus derivats com arduino</li>
                <li>Exemples de llenguatges sense punters: Python i Javascript</li>
            </ul>
            <p>El punter llegeix el contingut d'una adreça de memoria i tambe la posició de la mateixa adreça i pot manipular-la. Hi ha posicions d'adreçes especials, com els sectors d'arrancada.</p>
            <p>El punter serveix per tenir el control total per part del programador de la memoria i els recursos de l'ordinador</p>
            <p>El "Problema" que te es que pot provocar errors a la memoria o accesos no permesos si no saps com fer funcionar correctament el punter</p>
            <p>Els dos símbols per utilitzar punters son: L'arterisc "*", que serveix per llegir el contingut de l'adreça de memoria. I l'ampersand "&", que llegieix la posició de l'adreça de memoria</p>
            <p>La memoria de l'ordinador la podem imaginar com caixes d'una llista on cada caixa te un valor unic assignat en hexadecimal que comença per 0x. Cada caixa te un contingut que pot ser buit (0) o pot contenir un valor</p>
    <h4>Operacions avançades amb punters</h4>
            <ul>
                <li><b>Accés directe a la memoria:</b> Permet modificar valors en posicions especifiques.</li>
                <li><b>Manipulació eficient d'arrays i strings (cadenes):</b> L'array esencialment es una llista adreçes amb principi i final amb un punter al primer element.</li>
                <li><b>Passar grans quantitats de dades a funcions:</b> En lloc de copiar valors, els punters passen la seva adreça, estalviant memoria i temps. Aquest es un dels motius per els que C i derivats son mes rapids que python o JS.</li>
                <li><b>Creació d'estructures dinamiques:</b> Es pot crear coses com grafics o llistes enllaçades de forma facil</li>
                <li><b>Interacció amb microcontroladors senzilla:</b> Els microcontroladors utilitzen llenguatges de baix nivell (low-level languages) que son mes properes al hardware. Encara que, gracies a l'augment de la memoria, s'han pogut crear llenguatges com micropython o circutpython.</li>
            </ul>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
// Al principi del codi, abans de la funció de configuració "setup" i la funció principal 
// "loop" que s'executa continuament, hem d'escriure sempre variables o constants.
// A més, al principi del codi trobem les constants i variables globals, anomenades així perquè es poden cridar
// o executar des de qualsevol part del codi, a diferencia de les variables locals que es 
// defineixen i s'utilitzen dintre de la mateixa funció "loop" o una funció addicional.
// Davant de les variables i constants globals hauriem d'afegir les biblioteques necessàries per 
// fer funcionar el nostre codi ( amb "#include <nom_biblioteca.h> ) l'extensió "h" deriva de C
// i significa "biblioteca de headers" o encapçalaments.        
const int ledPin = 13;
const int dotDelay = 200
// "const" vol dir que la variable no es modificarà dins del codi, "int" vol dir integer, o sigui
// que el nombre que agafem haurà de ser enter, ja que els pins tenen números enters. El pin 13
// és especial, té una resistència interna en el cas d'Arduino uno que permet connectar directament
// un led, perquè està al costat del pin GND i puc clavar o connectar un led sense cap circuit o placa.
// "ledPin" és una variable constant i s'anomena així per l'usuari, utilitzant camelCase i referint-nos
// al que fa aquest pin.
char* letters[] = {
  ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..",    // A-I
  ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.",  // J-R
  "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."          // S-Z
};
// Més amunt i més abaix tinc dos arrays composats cadascun d'ells per arrays interns i cada array intern
// està composat de caracters que només poden ser "." o "-".
// Quan jo crido "letter[0]" el que obtinc ".-" o sigui, la lletra A en codi Morse.
// Aquesta forma de treballar és molt dolenta, des d'un punt de vista d'eficiència perquè estic utilitzant.
// un byte ( un byte són 8 bits ) sencer per cada punt o ratlla. 
// Un bit és un valor de 0 o 1 i això es podria utilitzar per fer els punts o ratlles perquè els dos valors
// són dos estats, o 0 o 1, es podria asignar el 0 al punt i la ratlla l'1, fent-ho més eficient.
// En un byte hi han 8 bits i per això es podrien fer 256 caracters diferents.
// Quants bytes de memòria necesitarem utilitzant bytes o bits per codificar Morse?
// Aproximadament el Morse té uns 109 punts o ratlles pels números o lletres, de la manera més eficient
// tindriem un ús de 14 bytes i de la manera menys eficient 872 bytes.
// Hem de tenir en compte
// De fet ASCII utilitza 7 bits per crear 128 caracters ( de 0 a 127 ).
// "*" és molt important, ja que ens indica que és un punter, "[]" ens indica que és una array,
//  "numbers" m'indica el valor de l'array, i char m'indica el tipus d'element ( que són caracters ) que hi ha dins
// de l'array.
// L'array de sota es diu numbers però està constituit per caracters, perquè tant els números com les lletres
// estan constituides per "." o "-" que són caracters
char* numbers[] = {
  "-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----."};

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
//En el setup o configuració del microcontrolador indiquem que el pin 13  que ara es diu "ledPin" sigui una sortida o "OUTPUT".
//Indiquem a l'Arduino que es comuniqui amb l'ordinador a través del port serial o sèrie i connecti a una velocitat de 9600 bauds o simbols/segon que són aprox 9600 bits/sego.
}

    void loop() {
//El loop és el codi principal, i el que el seu nom indica és que es repeteix sense parar en un "loop".
//"char" significa que utilitzem una variable de tipus caràcter i 'anomenem "ch".
//Serial.available significa si està disponible la comunicació sèrie o "serial monitor" que comunica el microcontrolador arduino amb el nostre ordinador o dispositiu
//La comunicació entre arduino i l'ordinador és complexa:
//Primer pas: l'ordinador envia dades al monitor sèrie a través de l'USB per un mecanisme que s'anomena "USB to serial"
//Segon pas: la transformació anterior d'USB to Serial la fa un xip especial dintre d'Arduino
//Tercer pas: les dades en format sèrie arriben a una part del microcontrolador amonenada "UART" que significa "Universal Asynchronous Receiver Transmiter" 
//Quart pas: l'UART envia les dades que rep a una memòria temporal o buffer que pot emmagatzemar 128 bytes fins que s'elimina en el moment que es llegeix.
    char ch;
  if (Serial.available() > 0) {
    ch = Serial.read();
    if (ch >= 'a' && ch <= 'z') {
      flashSequence(letters[ch - 'a']);
    }
    else if (ch >= 'A' && ch <= 'Z') {
      flashSequence(letters[ch - 'A']);
    }
    else if (ch >= '0' && ch <= '9') {
      flashSequence(numbers[ch - '0']);
    }
    else if (ch == ' ') {
      delay(dotDelay * 4);  // gap between words  
    }
  }
}

void flashSequence(char* sequence) {
  int i = 0;
  while (sequence[i] != NULL) {
    flashDotOrDash(sequence[i]);
    i++;
  }
  delay(dotDelay * 3);    // gap between letters
}

void flashDotOrDash(char dotOrDash) {
  digitalWrite(ledPin, HIGH);
  if (dotOrDash == '.') {
    delay(dotDelay);           
  }
  else { 
    // must be a dash 
    delay(dotDelay * 3);           
  }
  digitalWrite(ledPin, LOW);    
  delay(dotDelay); // gap between flashes
}
</code></pre>
<p> Negació. El signe d'admiració "!" significa negar la variable que es posa després del signe.</p>
<p> Hi ha dos variables inicials, que son constants per definició del codi. La variable ledPin es el pin el qual conectem
el led, que es 13 normalment. I el pin 5 es un pin on conectem un interruptor per entrada de dades. El pin 5 esta encés per defecte
perque li hem dit que es un input pull-up, significa que l'interruptor deixa pasar la corrent per defecte. Si fos un input només 
estaria a 0, es a dir, l'interruptor estaria obert. La variable switch open esta al principi amb valor 1 i quan movem el botó, 
l'apaguem perqué la variable switchOpen que estava a 1 es transforma a !switchOpen que esta a 0. I si li torno a negar, sortira 1.</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13
    void setup() {
     pinMode(ledPin, OUTPUT);
     pinMode(inputPin, INPUT_PULLUP);
    }
    void loop() {
     int switchOpen = digitalRead(inputPin);
     digitalWrite(ledPin, ! switchOpen);
    }
    </code></pre>
<p> Clica a la imatge següent per veure la simulació </p>
<a href = "https://www.tinkercad.com/things/6kmvYJBnQFx-circuit-54-monk" target = "_blank"> <img src = "54.PNG"> </a>
<p> Toggles. </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;

    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    void loop()  {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
  }
}
</code></pre>
<a href = "https://www.tinkercad.com/things/ijQ7CKiIRbu-circuit-55-monk" target = "_blank"> <img src = "55.PNG"> </a>

<p>solució amb llibreria </p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int inputPin = 5;
    const int ledPin = 13;
    int ledValue = LOW;
    
    void setup()  {
    pinMode(inputPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    }
    
    void loop() {
    if (digitalRead(inputPin) == LOW) {
     ledValue = ! ledValue;
     digitalWrite(ledPin, ledValue);
     delay(500);
    }
    }
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
         #include <Bounce2.h>
        const int inputPin = 5;
        const int ledPin = 13;
        int ledValue = LOW;
        Bounce bouncer = Bounce(); 

        void setup() {
        pinMode(inputPin, INPUT_PULLUP);
        pinMode(ledPin, OUTPUT);
        bouncer.attach(inputPin);
        // bouncer.interval(50); // interval in ms
        }

        void loop() {
        if (bouncer.update() && bouncer.read() == LOW) {
          ledValue = ! ledValue;
          digitalWrite(ledPin, ledValue);
        // El rebot de contacte (Contact Bounce) esta present en reles (Interruptors que canvia de estat depenent de l'electricitat), interruptors, contactes de bateria. Tots aquests
        // Estan fets per metalls elastics, de forma que quan yo apreto un interruptor mecanic, el metall rebota diverses vegades sobre el contacte, provocant una inestabilitat al
        // contacte
        }
        }
 </code>
</pre>
<p> Algunes sortides d'arduino i altres microcontroladors són PWM (Pulse Width Modulation). Com podem veure a la imatge de sota, es tracta
de una modulació de l'ample del pols. Es a dir, es modula el temps que es 0 o que es 1, aconseguint que en 0 s'apagui i en 1 s'encengui.
Nosaltres no observem que s'encengui o que s'apagui perque es molt rapid el canvi i la nostra visió no ens permet veure-ho. Nosaltres veiem
la llum en un percentatge que depen del percentatge de temps que ha estat ences la sortida </p>
<img src = "pwm.png">

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
    const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Enter Volts 0 to 5");
}

void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0;
    analogWrite(outputPin, pwmValue);
  }
}
</code></pre>
<p> El "const int outputPin" defineix el pin de sortida constant que no es pot canviar. Després de definir
el pin de sortida 3 i en output (sortida) i la velocitat bauds (9600), el codi demana que escrigui a la consola
del programa Arduino IDE: Enter volts 0-5.</p>
<p> Al loop principal comprova que hi hagi caràcters escrits a la consola, després agafa el valor que hem 
donat i el guarda en la variable volts. El valor pot ser en decimals perquè posa float ("Floating point number").
El mètode parseFloat l'apliquem amb la sintaxi del punt al objecte Serial (Que es posa en majúscula, normalment
seria una classe en majúscula) i agafa el valor de la consola sèrie</p>
<p> La variable pwmValue és entera (int o "integer") i el que fa és convertir el valor de volts (0-5) a valors
de 0-255, que és el numero de bits (2^8=256). Si fos un ESP32-S3 de 14 bits tal com indica el data
sheet o fulla de caracteristiques de el ESP32-S3la linea de codi seria:
"Serial.println("Enter Volts 0-3.3")
"int pwmValue = volts * 16384.0 / 3.3" </p>

<p> El ESP32-S3 te l'avantatge de tenir més resolució, es a dir,  pot donar 16384 valors diferents entre 0-3,3 volts
Aixó pot que no es noti en un led, peró es nota en un motor, on l'ESP32 permet accedir a més velocitats diferents. Els
motors poden arribar a 16 bits, que es 2^16 o 65536 valors diferents, depenent del tipus de motor, pot ser observat o no
</p>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
const int outputPin = 3;

void setup() {
  pinMode(outputPin, OUTPUT);
  Serial.begin(9600); //comença la comunicació serie USB entre l'arduino i l'ordinador a una velocitat de 9600 bauds (Simbols per segon) l'objecte serial es de la clase serial
  //i si li apliquem la sintaxi del punt el metode begin que té com a parametre o argument. I li apliquem a la sintaxi de punt a la clase serie, pot rebre diversos parametres, si 
  //els posem entre cometes escriu tal qual, i si no posem entre cometes son variables 
  Serial.println("Enter Volts 0 to 5"); //demana que el usuari entri per el monitor del arduino ide un numero entre 0 i 5. 
}
//void loop es el codi principal que no s'atura mai, es a dir, es repeteix fins que desconectem l'arduino. El metode avaliable es un metode que espera caracters, < 0 es
//que hi ha algun caracter, Serial.parsefloat es una funció que te la funcio de analitzar el contingut d'un caracter, i si es de tipus decimal (floating point number),les variables
//float incloeixen els int o integer (numeros sencers). També existeix el parse.int que només acceptaria numeros enters. El float volts crea un espai a la memoria anomenat volts,
//que haura de ser de floating point numbers, que emmagatzemara el valor parsejat del 
void loop() {
  if (Serial.available() > 0) {
    float volts = Serial.parseFloat();
    int pwmValue = volts * 255.0 / 5.0; //els volts no serveixen directament, perque volem valors entre 0 i 255, ja que son els valors del PWM, perque es el numero de bits. faig una regla de tres i multiplico el valor per 255 i ho divideixo entre 5. 
    //aquest valor es integer, i va al més proxim si dona decimal
    analogWrite(outputPin, pwmValue); 
  }
}
</code></pre>
<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600); // comença la comunicació sèrie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 símbols per segon).
}

void loop() {
  int number = random(1, 7); // escull un número enter aleatoriament del 1 el 7. (1, 7) és un interval així que agafem el 1, 2, 3...7
    // Els números aleatoris són importants per exemple en controls de qualitat perque  ens asegurem de tot no està decidit 
    per ningú
  Serial.println(number); // Perquè fem println i no fem print? perquè volem que surti una línea sobre una altre
  delay(500); // espera 500 millisegons
}
    
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

const int analogPin = 0; // El pin 0 en Arduino és el pin A0 (analog)

void setup() {
  Serial.begin(9600);
}

void loop() {
  int reading = analogRead(analogPin); // analogRead llegeix els valors analogics del analogPin de 0 a 1023
  float voltage = reading / 204.6; // 1023 / 5 = 204,6 Dividim 1023 (2^10 - 1 per a Arduino) entre 5 (volts d'Arduino)
                        // Ara ens interesa els volts perquè jo connecto un sensor por esemple de temperatura ( de 0 a 100
    graus, d'humitat 0% - 100%) i els valor de 0 a 1023 no tenen sentit, perquè si fos un altre ESP32 seria de 0 a 4095
    i el valor 500 en el primer cas estaria per la meitat i en el segon cas seria menys. Si utilitzem voltatge tenim una mesura
    real del que està passat en el sensor i buscarem la relació entre els volts i la temperatura / humitat a la fulla de 
    característiques (datasheet), una vegada tenir la relació farem una regla de 3 o un mapejat.
  Serial.print("Reading="); // Quan poso entre cometes el print em surt tal qual la paraula reading= que significa lectura
  Serial.print(reading); // reading no té cometes i és una variable que conté valors entre 0 i 1023
  Serial.print("\t\tVolts="); // \t deixa un espai de tabulador. 
  Serial.println(voltage); // Ens donarà el valor en volts al costat de Volts=
    // Com quedarà en el cas de reading 512?
    // Reading=512        Volts=2.5 // espera mig segon per der una altre lectura
    // Reading=256        Volts=1.25
  delay(500);
}

</code></pre>


<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600); // comença la comunicació sèrie USB entre Arduino i l'ordinador a una velocitat de 9600 bauds (9600 símbols per segon).
}

void loop() {
  int number = random(1, 7); // escull un número enter aleatoriament del 1 el 7. (1, 7) és un interval així que agafem el 1, 2, 3...7
    // Els números aleatoris són importants per exemple en controls de qualitat perque  ens asegurem de tot no està decidit 
    per ningú
  Serial.println(number); // Perquè fem println i no fem print? perquè volem que surti una línea sobre una altre
  delay(500); // espera 500 millisegons
}
    
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">

void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0)); // seed significa llavor i té com argument un número, si per exemple poso randomSeed (4) 
    sempre em sortirà la mateixa cadena de números aleatoris.
}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
</code></pre>
</div>

<div class="content-container">
    <h2>Numeros aleatoris, perque son imporannts y com es fan</h2>     
    <p> La funció random de Ardunio IDE deriva de la funció rnd del llenguatge C i C++ i fuaniona de la mateixa manera. 
        No genera números aleatoris sinó pseudoaleatois, perque estan creats per un algorisme o algoritme, anomenat "Generador líneal congruecial". 
        Aquet algoritme és determinista, sempre onara els mateixos resulatats.
        La funció random necesita una llavo o seed per generar els números i sinó s'indica acostuma a ser 1 o 0, en Arduino és 1.  Donarem un exempe matematic</p>

                    
<h1>Generació de Nombres Pseudoaleatoris: LCG + Arduino</h1>

<h2>1. Algorisme LCG (Linear Congruential Generator)</h2>
  <p>
    L’algorisme congruencial lineal genera seqüències pseudoaleatòries segons la fórmula de recursió:
  </p>
  <div>
    \[
      X_{n+1} \;=\; \bigl(a \cdot X_n + c\bigr)\;\bmod\; m
    \]
  </div>
  <p>On:</p>
  <ul>
    <li><strong>\(X_n\)</strong> = valor anterior.</li>
    <li><strong>\(a\)</strong> = multiplicador.</li>
    <li><strong>\(c\)</strong> = increment.</li>
    <li><strong>\(m\)</strong> = mòdul.</li>
    <li><strong>\(X_0\)</strong> = llavor inicial (seed).</li>
  </ul>

  <h3>Exemple Numèric Pas a Pas</h3>
  <p>Suposem:</p>
  <ul>
    <li>\(a = 5\)</li>
    <li>\(c = 3\)</li>
    <li>\(m = 16\)</li>
    <li>\(X_0 = 7\)</li>
  </ul>
  <ol>
    <li>
      \(X_1 = (5 \times 7 + 3) \bmod 16 = 38 \bmod 16 = 6\)
    </li>
    <li>
      \(X_2 = (5 \times 6 + 3) \bmod 16 = 33 \bmod 16 = 1\)
    </li>
    <li>
      \(X_3 = (5 \times 1 + 3) \bmod 16 = 8  \bmod 16 = 8\)
    </li>
    <li>
      \(X_4 = (5 \times 8 + 3) \bmod 16 = 43 \bmod 16 = 11\)
    </li>
    <li>
      \(X_5 = (5 \times 11 + 3) \bmod 16 = 58 \bmod 16 = 10\)
    </li>
  </ol>
  <p><strong>Seqüència completa:</strong> 7, 6, 1, 8, 11, 10</p>
<p>
  When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are
  \[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]
</p>
<h1> Numeros aleatoris i arduino </h1>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
void setup() {
  Serial.begin(9600);
  randomSeed(analogRead(0));
}

void loop() {
  int number = random(1, 7);
  Serial.println(numbera);
  delay(500); 
}
</code></pre>

<pre><button class="copy-btn" onclick="copyCode(this)"><i class="fas fa-copy"></i></button><code class="language-arduino">
        void setup() {
    Serial.begin(9600);
    randomSeed(analogRead(0)); //genera numeros aleatoris de forma potent. Si dintre de randomSeed posem un número, sempre
    //sortira el mateix número aleatori com pasa amb el <a href="https://pompeu.neocities.org/arduino/random/seed">
    //exemple del profesor</a> on podem canviar la seed o llavor i comprovar-ho
    /*Aquests valors seran aleatoris en el cas que no hi hagi res conectat a A0. Si conectem un simple cable a A0 observarem que 
    quan toquem amb els dits o inclús sense tocar hi ha un senyal de soroll que es mou entre 0 i 1023 mormalment pel rang baix. 
    L' aire és una barreja complexa de gasos en moviment i l'entrada analògica és un sistema molt sensible molt sensible en 
    aquests gasos. Resumint analogRead(0) donarà alors eners aleatoris i serà la nostra primera capa d'aletorietar. La segona
    capa de la aletorietat és randomSeed perquè utilitza un algortme "lineal conggruencial", que es basa an un mètode recursiu,
    és a dir, que agafa el número el multipliquem per un nuero fix que no cavia mai i el sumem amb el número fiix que no canvia
    mai (només canvia si canviem el llenguatge de programació o la versió del lleguate). Quan ja tenim aquest número fem una
    operació mòdul per obtenir el número aleatori, aixo vol dir diiir el número obtingut entre en número conegut (sempre igual)
    i el residu serà pseudoaleatori. 
          
    Perque és pseudoaleatori?
    Sempre serà la mateixa seüencia si fessim randomSeed(4), i la mateixa seqüencia si fessim randomSeed(x) sent "x" qualsevol 
    número.
    
    Perque no puc saber quin numero aleatori sortirà?
    Encara que hi ha una relació matemàtica entre el número de llavor i el número aleatori perquè el número de llavor és aleatori
    (analogRead(0)). Perquè és un número pseudoaleatori d'un número aleatori perquè la funció randomSeed() és pseudoaleatòria i 
    analogRead(0) és aleatòria pel soroll de fons.

    Pot servir per tener sempre els mateios números?
    Sí, perquè quan triem una Seed determinada sempre tindrem una seqüència. Pot ser útil perquè jo puc fer un aparell o 
    o programa amb una randomSeed(184) i si li dic a un altre investigador o altre fabricant de hardware la meva llavor (seed) 
    podrà reproduir els meus resultats.

    A més a més de random hem de conèixer les funcions matemàtiques d'Arduino que poden ser útils per fer càlculs, per exemple, 
    per convertir valors de 0 a 1023 en valors de temperatura, humitat, concentració d'un contaminant, etc.
    */

    
    <li>La <b>abs</b> donarà el valor absolut serà el número sense signe, per exemple abs(12) = 12, i abs(-12) = 12</li>
    <li>La funció <b>constrain</b> fa constrenyir o reduir un número d'un rang determinat. La funció té 3 números o arguments. 
    El primer argument és el número que volem constrenyir, el segon número és el principi del rang i el tercer número és el final 
    del rang permès.
    <ul>
      <li>constrain(8,1,10); ens retorna el número 8, perques esta en el rang de 1 a 10.</li>
      <li>constrain(11,1,10); ens retorna el número 10, ja que no pot ser més gran que 10</li>
      <li>constrain(0,1,10); ens retorna el número 1, ja que no pot ser més petit que 1</li>
    </ul>
    </li>
    <li>La funció <b>map</b> té 5 arguments. El primer és el número que ens interessa que està a dins del primer rang, el segon és 
        el número mínim del primer rang, el tercer número és el màxim del primer rang, el quart és el número mínim del segon rang i 
        finalment, el cinquè número és el número màxim del tercer rang. Per exemple
        map(200, 0, 1023, 0, 100);
    </li>


}

void loop() {
  int number = random(1, 7);
  Serial.println(number);
  delay(500); 
}
</code></pre>

</div>
</body>
</html>
